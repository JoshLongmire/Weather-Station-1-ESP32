---
alwaysApply: true
description: Firmware rules for ESP32 Weather Station v20 modular architecture (Arduino IDE 2.3.6, ESP32-S3/classic ESP32)
globs: *.ino,*.cpp,*.h
---

## ESP32 Weather Station – Cursor Rules

Reference files:
- **v20 Modular:** [WeatherStationv20_modular.ino](mdc:WeatherStationv20_modular/WeatherStationv20_modular.ino) ← **PRIMARY**
- **v18 Legacy:** [WaetherStation08_24_25_v18.ino](mdc:WaetherStation08_24_25_v18.ino/WaetherStation08_24_25_v18.ino.ino)
- README: [README.md](mdc:README.md)
- API & schema: [docs/API.md](mdc:docs/API.md)

### Architecture Evolution: v18→v20
**v20 introduces modular architecture:**
- **Main orchestrator:** 336 lines (coordination only)
- **7 modules:** config, sensors, weather, power, storage, mqtt, web
- **100% backward compatibility:** All APIs, CSV schema, and behavior preserved
- **Benefits:** Isolated changes, easier maintenance, reduced merge conflicts

### Build and environment
- Target: Arduino IDE 2.3.6+, board "ESP32S3 Dev Module" (Lonely Binary ESP32-S3 Dev Board, 16MB Flash / 8MB PSRAM) or classic "ESP32 Dev Module"
- Language: Arduino C++ (ESP32 core). Keep code portable to classic ESP32; guard ESP32‑S3-specific features with `#if defined(CONFIG_IDF_TARGET_ESP32S3) || defined(ARDUINO_ESP32S3_DEV)`
- Libraries already in use (prefer these; document any additions in `README.md`):
  - Core: `WiFi`, `WebServer`, `ESPmDNS`, `SPI`, `SD`, `Preferences`, `Wire`, `time.h`, `esp_sleep.h`, `esp_system.h`, `driver/rtc_io.h`, `vector`
  - Sensors: `Adafruit_BME680`, `Adafruit_Unified_Sensor`, `Adafruit_VEML7700`, `RTClib` (DS3231)
  - Utility: `ArduinoJson`, `ElegantOTA`, `math.h`, `stdarg.h`
  - Optional: `SdsDustSensor` (SDS011 PM2.5/PM10 support)
- Do not introduce blocking watchdog‑risky code in `loop()`; keep new work non‑blocking or time‑sliced.

### Project anchors and invariants
- **v20 Modular structure:** Work with modules in `config.h`, `sensors.h`, `weather.h`, `power.h`, `storage.h`, `mqtt.h`, `web.h`
- **Main orchestrator pattern:** Keep main `.ino` file focused on coordination, not implementation
- HTTP endpoints and schemas are defined by handlers in the web module. Treat `/live` JSON and `/logs.csv` header as a stable API.
  - **JSON:** Only add new fields; never rename or remove existing ones. Ensure defaults when sensors are absent.
  - **CSV (v18.2, 30 columns):** 
    ```
    timestamp,temp_f,humidity,dew_f,hi_f,pressure,pressure_trend,forecast,lux,uv_mv,uv_index,voltage,voc_kohm,mslp_inHg,rain,boot_count,pm25_ugm3,pm10_ugm3,wind_mph,wind_dir,wind_gust_mph,rain_1h,rain_today,rain_event,leaf_raw,leaf_pct,leaf_wet,leaf_wet_hours,eto_hourly,eto_daily
    ```
    Append new columns only at the end and update `/view-logs` table rendering accordingly.
- Persistent settings (`Preferences` namespace `app`) managed by config module as JSON string. When adding settings:
  - Extend `AppConfig` struct, update `loadAppConfig()` and `saveAppConfig()` with backward‑compatible defaults.
  - Update `/config` GET/POST form fields and help text in web module.
  - Current config fields: `altitude_m`, `temp_unit`, `bat_cal`, `time_12h`, `lux_enter_day`, `lux_exit_day`, `log_interval_min`, `sleep_minutes`, `trend_threshold_hpa`, `rain_unit`, `rain_tip_in`, `rain_debounce_ms`, `mdns_host`, `sds_mode`, `leaf_debug`, `leaf_adc_dry`, `leaf_adc_wet`, `leaf_wet_on_pct`, `leaf_wet_off_pct`, `eto_unit`, `latitude`, `debug_verbose`
- Power model (DAY/NIGHT) and timing managed by power module:
  - Respect `UPTIME_STARTUP` (1800s = 30 min) / `UPTIME_CONFIG` (120s = 2 min) windows and `updateDayNightState()` decisions.
  - Use `prepareDeepSleep()` to enter sleep; it programs RTC A1 alarm (minute match) and ESP32 timer wake, then enters deep sleep.
  - Initial boot: 30-minute config window → 2-minute decision run → normal DAY/NIGHT cycling.

### Concurrency, ISR, and timing rules
- ISRs must be extremely short and placed in IRAM (`IRAM_ATTR`). No heap allocation, no `Serial`, no long math.
- **ISRs belong in sensors module:** `rainIsr()`, `windIsr()` - maintain in sensors.cpp with proper critical sections
- Shared ISR state must be `volatile` and protected with `portENTER_CRITICAL`/`portEXIT_CRITICAL` when copied in tasks.
- Active ISRs:
  - `rainIsr()` — Rain gauge tipping bucket (GPIO18, FALLING edge, debounced via `rainDebounceMsRuntime`)
  - `windIsr()` — Hall anemometer pulses (GPIO7, FALLING edge, 5ms debounce)
- New periodic work should piggyback on existing cadence mechanisms:
  - Use `performLogging()` cadence (`LOG_INTERVAL_MS`, configurable via `log_interval_min`) for SD writes.
  - For UI refresh, use the `/live` handler (polled every 2 seconds by dashboard) rather than adding timers in `loop()`.
  - Wind 1-hour rolling average: sampled once per minute in `loop()` via `windAvg1hLastSampleMs` timer.
  - Leaf wetness: sampled every `LEAF_READ_MS` (1 second) via `leafLastReadMs` timer; wet-hours accumulated per minute via `nextWetTickMs`.
  - Do not add long `delay()` calls. Use millisecond scheduling with `millis()` comparisons.

### Modular Development Patterns (v20)

#### When Making Changes
1. **Identify the correct module** based on primary responsibility:
   - **config:** Settings, preferences, calibration values
   - **sensors:** Hardware I/O, ISRs, raw data collection  
   - **weather:** Calculations, forecasting, derived metrics
   - **power:** Sleep management, day/night modes, LED control
   - **storage:** SD operations, CSV logging, file management
   - **mqtt:** MQTT client, publishing, broker communication
   - **web:** HTTP routes, HTML/JSON responses, OTA
2. **Respect module boundaries:** Don't mix sensor I/O with web serving, or config with weather calculations
3. **Use clean interfaces:** Pass data via function parameters, not hidden global access
4. **Maintain isolation:** Each module should compile with minimal dependencies

#### Cross-Module Communication
- **Main orchestrator calls modules:** `loop()` coordinates via `updateWindAverage()`, `handleMqtt()`, `performLogging()`, etc.
- **Modules expose data via public functions:** `getSensorData()`, `getWeatherForecast()`, not direct global access
- **Config module provides settings:** Other modules call `getConfigValue()` or access `appCfg` read-only
- **Avoid tight coupling:** Don't make sensor module depend on web module, etc.

### Sensor and I/O guidelines
- **All sensor logic belongs in sensors module** - Initialize I²C devices after `Wire.begin()` in `initializeSensors()`
- Initialize I²C devices after `Wire.begin(I2C_SDA, I2C_SCL, SENSOR_I2C_FREQ_HZ)` and check return codes. Gate usage by a `*_Ok` boolean flag.
- **BME680:** Call `performReading()` before accessing fields. Use `Adafruit_BME680` library (not BSEC2). Gas resistance is in Ω; divide by 1000 for kΩ.
- **VEML7700:** Configure for max range (0-120k lux): `setGain(VEML7700_GAIN_1_8)`, `setIntegrationTime(VEML7700_IT_25MS)`. Guard against `NaN`/negative lux.
- **SDS011 (optional):** 
  - UART on Serial2 (RX=16, TX=17, 9600 baud)
  - Duty cycling via `sds_mode` config: `off|pre1|pre2|pre5|cont`
  - 30-second warm-up period (`SDS_DUTY_WARMUP_MS`) after wake; accumulate raw PM values for averaging.
  - Auto-sleep enforcement in 2-minute serve window using vendor frames (`SDS_WAKE_CMD`, `SDS_SLEEP_CMD`).
  - Persist last PM values in `RTC_DATA_ATTR` for fallback during brief serve windows.
- **Wind vane (PCF8574, optional):**
  - I²C addresses 0x20-0x27 (auto-detected)
  - Active-low reed switches (write 0xFF to set pins as inputs)
  - Majority vote of 3 samples (300µs apart) for stability
  - Decode to 8-point compass: N, NE, E, SE, S, SW, W, NW
  - Handle dead zones (return last valid direction)
- **Leaf wetness (LM393, optional):**
  - Analog pin: 3 (S3), 34 (classic ESP32)
  - EMA smoothing with `LEAF_EMA_ALPHA = 0.20`
  - Calibrate `LEAF_ADC_DRY` and `LEAF_ADC_WET` for your sensor
  - Hysteresis: `LEAF_WET_ON_PCT = 55.0`, `LEAF_WET_OFF_PCT = 45.0`
  - 24-hour wet-hours accumulation in RTC memory ring buffer
- **ADC battery reading:** Must maintain attenuation (`ADC_11db`) and 8-sample averaging; keep `batCal` multiplier configurable.
- **SD card I/O:**
  - Always check `SD.begin()` and handle `SD.exists("/logs.csv")` safely.
  - Use `FILE_APPEND` mode and always `close()` files after write.
  - Keep log writes compact; avoid large `String` concatenations in tight loops.
  - Use `server.send()` with complete HTML string for `/view-logs` (not chunked encoding).

### Web/UI & OTA
- Keep `/` dashboard responsive; avoid adding heavy inline scripts. Favor small, client‑side Canvas charts already present (180-point rolling history).
- `/live` should remain < 1.5 KB JSON typical. When adding fields, keep names short and include units in separate fields only if necessary.
- `/view-logs` must render dark theme HTML with filters. Use `server.send(200, "text/html; charset=utf-8", html)` without separate headers or chunked encoding.
- Preserve `/update` (ElegantOTA) with basic auth. Default credentials: username `weatherstation1`, password `12345678`. Change before deployment.
- mDNS host defaults to `weatherstation1.local` (configurable via `/config` `mdns_host` field). Update all occurrences when changing.

### Stability and error handling
- Prefer guard clauses and early returns. Check pointers/handles and return on failure.
- Never crash the main loop for optional peripherals; report status via `/live` health flags:
  - `sd_ok`, `rtc_ok`, `bme_ok`, `sds_ok`, `wind_ok`, `wind_vane_ok`
- When adding new subsystems, expose a boolean health field in `/live` and degrade gracefully if absent.
- AP fallback timeout: 3-minute stuck AP detection in `loop()` triggers `ESP.restart()`.

### Naming and code style
- Use descriptive names (no 1–2 letter identifiers). Functions are verbs; variables are nouns.
- Avoid deep nesting; handle errors first. Only add comments for non‑obvious logic.
- Match existing formatting; do not reformat unrelated code. Avoid inline explanatory comments; place brief comments above complex blocks.
- Debug output: Use `debugPrintf()` helper (respects `appCfg.debugVerbose` flag) instead of raw `Serial.print()` for conditional logging.

### Extensibility patterns
- **Feature flags:** Prefer `#define ENABLE_<FEATURE>` blocks near the top of the sketch for optional hardware:
  - `ENABLE_SDS011` (default: 1)
  - `ENABLE_BSEC2` (default: 0, uses `Adafruit_BME680` instead)
  - `ENABLE_WIND` (default: 1)
  - `ENABLE_WINDVANE` (default: 1)
  - `ENABLE_LEAF` (default: 1)
  - Ensure all code compiles with flags off.
- **New modules:** Place reusable logic in `.h/.cpp` files and include from the main sketch. Keep external APIs small and explicit.
- **Data model:** For new derived metrics, compute once per cycle and reuse across logging and `/live` to avoid duplication.
- **Backward compat:**
  - Config: tolerate missing keys in `loadAppConfig()`; write all keys in `saveAppConfig()`.
  - Logs: keep existing columns intact; when adding, append at end and update `/view-logs` table columns and filter field mappings.

### Testing checklist for edits
Before merging any edit, verify:
- Compiles for ESP32-S3 Dev Module and classic ESP32 Dev Module in Arduino IDE 2.3.6+ with current libraries.
- Boots with no SD present (graceful `sd_ok=false`), no RTC present (timer fallback, `rtc_ok=false`), and no optional sensors (status flags false) without crash.
- `/live` responds within ~50 ms and includes all required fields.
- CSV header present after `/reset`; rows appended once per wake cycle (respect `loggedThisWake` flag).
- Deep sleep triggers after serve windows in NIGHT mode; DAY mode continues periodic logging.
- Status LED behavior: AP mode solid ON, connected STA slow blink, disconnected calm (LED OFF).
- SDS011 duty cycling: sensor sleeps when not in use per configured preset.

### Known integration points
- **Day/Night thresholds:** Set via Preferences (`lux_enter_day`, `lux_exit_day`) and exposed on `/config`. State machine in `updateDayNightState()` uses 30-second dwell.
- **Pressure trend:** Uses 13-slot hourly history in `RTC_DATA_ATTR` arrays (`pressureHourly_hPa`, `pressureHourlyUnix`). Classifier threshold from `appCfg.trendThresholdHpa`.
- **Rain gauge:** ISR uses 128-entry ring buffer of millisecond timestamps. Compute rates by copying under critical section. Accumulation totals (1h, daily, event) maintained in `RTC_DATA_ATTR`.
- **Wind anemometer:** ISR uses 128-entry ring buffer. Gust = highest 5-second sample in last 10 minutes. 1-hour rolling average sampled once per minute.
- **Leaf wetness:** 1440-entry ring buffer in `RTC_DATA_ATTR` for 24-hour wet-hours accumulation. Daily rollover at local midnight.

### Security notes
- **OTA credentials:** Static basic auth in `setupOTA()`. Default: `weatherstation1:12345678`. Change before deployment.
- **AP credentials:** Static in `startAPMode()`. Default: `WeatherStation1:12345678`. Change before deployment.
- All endpoints are HTTP; assume trusted LAN. Do not add secrets to logs or `/live`.
- Do not expose device to public internet without reverse proxy + authentication.

### Pin Assignments (ESP32-S3 Lonely Binary)
- I²C: SDA=8, SCL=9, Frequency=100kHz
- SD: CS=5, SCK=12, MISO=13, MOSI=11
- Battery ADC: Pin 4 (11db attenuation, 100k/100k divider)
- Rain gauge: Pin 18 (FALLING edge ISR)
- Wind anemometer: Pin 7 (FALLING edge ISR)
- Wind vane PCF8574: I²C 0x20-0x27
- DS3231 RTC INT: GPIO_NUM_2 (EXT0 wake source)
- Status LED: Pin 37
- UV sensor: Pin 6 (analog)
- Leaf wetness: Pin 3 (analog, S3) or Pin 34 (classic ESP32)
- SDS011 UART: RX=16, TX=17

### Classic ESP32 Pin Differences
- I²C: SDA=21, SCL=22
- Leaf wetness: Pin 34 (instead of 3)
- Other pins same as S3
